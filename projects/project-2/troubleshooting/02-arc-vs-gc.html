<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARC vs GC - 메모리 관리 모델 비교 - Portfolio 2026</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../../assets/css/reset.css">
  <link rel="stylesheet" href="../../../assets/css/global.css">
  <link rel="stylesheet" href="../../../assets/css/layout.css">
  <link rel="stylesheet" href="../../../assets/css/troubleshooting.css">
</head>
<body>
  <!-- Project Header -->
  <header class="project-header">
    <h1 class="project-name">퀵라벨타이머 <span class="project-version">(v1.1.0)</span></h1>
  </header>

  <main class="troubleshooting type-b">
    <!-- Navigation -->
    <a href="../index.html" class="troubleshooting-nav">&larr; 프로젝트로 돌아가기</a>

    <!-- Title -->
    <h1 class="troubleshooting-title">ARC vs GC &mdash; 메모리 관리 모델 비교와 순환 참조 해결</h1>

    <!-- Section: 주제 -->
    <section class="troubleshooting-section">
      <h2 class="section-title">📌 주제</h2>
      <div class="section-box">
        <div class="section-content">
          <ul>
            <li>Java에서는 신경 쓰지 않던 순환 참조가 Swift에서 왜 문제가 되는가?</li>
            <li><strong>Java (GC)</strong>: 도달 불가능한 객체를 자동 수집, 순환 참조도 GC가 처리</li>
            <li><strong>Swift (ARC)</strong>: 참조 카운트 기반, 순환 참조를 감지 못함</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Section: 핵심 차이점 -->
    <section class="troubleshooting-section">
      <h2 class="section-title">🔀 핵심 차이점</h2>
      <div class="diff-grid">
        <!-- Java Column -->
        <div class="diff-column">
          <h3>☕ Java (GC)</h3>
          <ul>
            <li><strong>Garbage Collector:</strong> 도달 불가능한 객체 자동 수집</li>
            <li><strong>순환 참조 처리:</strong> GC가 자동으로 감지하고 해제</li>
            <li><strong>개발자 부담:</strong> 메모리 관리에 신경 쓸 필요 거의 없음</li>
            <li><strong>단점:</strong> GC 실행 시 일시적 성능 저하 (Stop-the-World)</li>
          </ul>
        </div>

        <!-- Swift Column -->
        <div class="diff-column">
          <h3>🍎 Swift (ARC)</h3>
          <ul>
            <li><strong>Automatic Reference Counting:</strong> 참조 카운트 기반</li>
            <li><strong>순환 참조 문제:</strong> 자동 감지 불가, 수동으로 끊어야 함</li>
            <li><strong>키워드:</strong> weak, unowned로 약한 참조 선언</li>
            <li><strong>장점:</strong> 예측 가능한 메모리 해제, 실시간 성능</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Section: 문제 상황 -->
    <section class="troubleshooting-section">
      <h2 class="section-title">🔴 문제 상황</h2>
      <div class="section-box">
        <div class="code-block">
          <pre>// ❌ 순환 참조 발생
class TimerViewModel {
    var cancellables = Set&lt;AnyCancellable&gt;()
    var timers: [TimerRecord] = []

    init(repository: TimerRepository) {
        repository.timersPublisher
            .sink { self.timers = $0 }  // 💥 강한 참조!
            .store(in: &cancellables)
        // ViewModel → cancellables → closure → self(ViewModel) → 순환!
    }
}</pre>
        </div>
        <p style="margin-top: var(--spacing-md); color: #C62828;">
          <strong>결과:</strong> ViewModel이 해제되지 않아 메모리 누수 발생
        </p>
      </div>
    </section>

    <!-- Section: 해결책 -->
    <section class="troubleshooting-section">
      <h2 class="section-title">🟢 해결책</h2>
      <div class="section-box">
        <div class="code-block">
          <pre>// ✅ [weak self]로 순환 참조 해결
class TimerViewModel {
    var cancellables = Set&lt;AnyCancellable&gt;()
    var timers: [TimerRecord] = []

    init(repository: TimerRepository) {
        repository.timersPublisher
            .sink { [weak self] timers in
                self?.timers = timers  // 약한 참조로 순환 끊음
            }
            .store(in: &cancellables)
    }
}</pre>
        </div>
        <p style="margin-top: var(--spacing-md); color: #2E7D32;">
          <strong>결과:</strong> ViewModel 해제 시 정상적으로 메모리 반환
        </p>
      </div>
    </section>

    <!-- Section: 요약 비교표 -->
    <section class="troubleshooting-section">
      <h2 class="section-title">📊 요약 비교표</h2>
      <table class="comparison-table">
        <thead>
          <tr>
            <th>관점</th>
            <th>☕ Java (GC)</th>
            <th>🍎 Swift (ARC)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>메모리 관리</strong></td>
            <td>Garbage Collector</td>
            <td>Reference Counting</td>
          </tr>
          <tr>
            <td><strong>순환 참조</strong></td>
            <td>GC가 자동 처리</td>
            <td>수동으로 끊어야 함</td>
          </tr>
          <tr>
            <td><strong>키워드</strong></td>
            <td>없음</td>
            <td>weak, unowned</td>
          </tr>
          <tr>
            <td><strong>리스너 해제</strong></td>
            <td>권장</td>
            <td>필수</td>
          </tr>
          <tr>
            <td><strong>메모리 해제 시점</strong></td>
            <td>GC 실행 시 (비결정적)</td>
            <td>참조 카운트 0 시 (결정적)</td>
          </tr>
        </tbody>
      </table>
    </section>

    <!-- Section: 배운 점 -->
    <section class="troubleshooting-section">
      <h2 class="section-title">💡 배운 점</h2>
      <div class="section-box">
        <div class="section-content">
          <ul>
            <li><strong>메모리 디버깅 방법론은 전이된다:</strong> 할당 프로파일링, 소유권 추적, 유지 경로 식별 등의 방법론은 언어와 무관하게 적용됩니다.</li>
            <li><strong>클로저와 콜백의 위험성:</strong> 클로저 내에서 self를 캡처할 때 순환 참조 위험을 항상 고려해야 합니다. Java에서도 익명 클래스/람다에서 유사한 주의가 필요합니다.</li>
            <li><strong>Xcode Instruments 활용:</strong> Memory Graph Debugger로 순환 참조를 시각적으로 확인할 수 있어, 문제 진단이 수월했습니다.</li>
            <li><strong>리스너 패턴의 주의점:</strong> Java에서는 습관적으로 해제하지 않던 리스너가 Swift에서는 필수라는 것을 배웠습니다.</li>
          </ul>
        </div>
      </div>
    </section>
  </main>
</body>
</html>
