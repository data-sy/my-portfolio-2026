# 프로젝트 1: 대규모 트래픽 환경 성능 튜닝 프로젝트

## 기본 정보
- 프로젝트 이름: 대규모 트래픽 환경 성능 튜닝 프로젝트
- 영문 이름: backend-performance-lab
- 버전: v1.0.0
- 기간: 2026.01.00 ~ 01.00 (3주)
- 역할: 1인 개발 (설계, 구현, 테스트, 인프라 구축 전체)
- 기술 스택: Java, Spring Boot, JPA, Redis, MySQL(RDS), Terraform, AWS ECR

## 프로젝트 개요
- 서비스 설명: 대규모 E-Commerce 플랫폼을 가정하여, 회원 100만 명·일평균 주문 5만 건 규모의 트래픽 환경에서 발생하는 성능 병목을 재현·측정하고 개선한 프로젝트
- 개발 배경: 실무에서 마주칠 대규모 트래픽 상황을 미리 경험하고, 성능 병목을 직접 재현·측정·개선하는 과정을 통해 백엔드 성능 튜닝 역량을 키우기 위해 시작
- 주요 기능: 상품 목록 조회 (카테고리 필터 + 정렬 + 페이징), 주문 상세 조회 (연관 엔티티 포함), 실시간 판매량 랭킹 TOP 100, 선착순 쿠폰 발급 / 재고 차감 (동시성 제어)

## 정량적 성과
- 성과 1: DB 인덱스 최적화를 통한 상품 목록 조회 성능 93% 개선 (2.5초 → 180ms)
- 성과 2: N+1 문제 해결로 주문 상세 조회 성능 81% 개선 (800ms → 150ms)
- 성과 3: Redis Sorted Set으로 실시간 랭킹 조회 98% 개선 (200ms → 5ms)
- 성과 4: 동시성 제어 비교로 상황별 락 전략 선택 기준 확보

## 인사이트
- 배운 점 1: 인덱스는 "컬럼 추가"가 아니라 WHERE 조건 + 정렬/페이징 패턴까지 포함한 설계 문제이며, EXPLAIN 기반 검증을 통해 각 시도의 효과를 정확히 측정해야 함
- 배운 점 2: ORM 사용 시 편의성만 보지 말고 실제 실행 쿼리 수와 I/O 비용을 반드시 확인해야 함
- 배운 점 3: 랭킹처럼 읽기 빈도가 높고 정렬이 핵심인 문제는 RDB 집계보다 적합한 자료구조를 쓰는 게 효과적
- 배운 점 4: 동시성은 "정답 락"이 아니라 정확성·성능·사용자 경험·인프라 환경을 함께 보고 선택해야 함

## 트러블슈팅 목록

### 트러블슈팅 1 (Type: A)
- 제목: DB 인덱스 최적화를 통한 상품 목록 조회 성능 93% 개선
- 문제 상황: Full Table Scan으로 상품 목록 조회 응답시간 2.5초
- 해결 과정:
  - 시도 1: category 단일 컬럼 인덱스 생성 → 2.5초 → 1.8초 (28% 개선), 그러나 여전히 filesort 발생
  - 시도 2: created_at 단일 컬럼 인덱스 생성 → 2.1초 (16% 개선), filesort 제거되었으나 category 필터링 비효율
  - 시도 3: (category, created_at DESC) 복합 인덱스 적용 → 조회 패턴 전체 커버
- 결과: 응답시간 2.5초 → 180ms (93% 개선)
- 배운 점: 인덱스는 WHERE 조건 + 정렬/페이징 패턴까지 포함한 설계 문제이며, 단일 인덱스로는 복합 조건을 효율적으로 처리할 수 없음

### 트러블슈팅 2 (Type: A)
- 제목: N+1 문제 해결로 주문 상세 조회 성능 81% 개선
- 문제 상황: 주문 상세 조회 시 쿼리 21개(1+N) 발생, 응답시간 800ms
- 해결 과정:
  - 시도 1: @EntityGraph 사용 → 쿼리 3개로 감소, 650ms (19% 개선), 그러나 일부 지연 로딩 여전히 발생
  - 시도 2: JPQL Fetch Join 적용 → 쿼리 1개, 600ms (25% 개선), 그러나 데이터 전송량 증가
  - 시도 3: Fetch Join + 반정규화 전략 병행 → 반복 계산/조회 요소 최소화
- 결과: 쿼리 21개 → 1개, 800ms → 150ms (81% 개선)
- 배운 점: N+1 해결이 목표가 아니라 전체 응답 시간 단축이 목표이므로, 쿼리 수 외에도 데이터 전송량과 계산 비용까지 고려한 최적화가 필요함

### 트러블슈팅 3 (Type: C)
- 제목: Redis Sorted Set으로 실시간 랭킹 조회 98% 개선
- 기초 질문: "실시간 판매량 TOP 100을 매번 조회한다면?"
- 파생 질문: 매 요청마다 전체 테이블 정렬하면 부하가 얼마나 될까? / 캐싱하면 해결될까? 갱신은 어떻게? / 랭킹에 최적화된 자료구조가 있을까?
- AS-IS: 판매량 TOP 100 조회 응답시간 200ms, 매 요청마다 전체 상품 테이블 정렬 발생
- 독립적 해결책:
  - A. DB 인덱스 추가: 200ms → 150ms (25% 개선) — 여전히 매 요청마다 정렬 비용 발생
  - B. Redis String 캐싱: 200ms → 20ms (90% 개선) — 갱신 시 전체 재계산 필요, race condition 위험
  - C. Redis Sorted Set: 200ms → 5ms (98% 개선) — 조회·갱신 모두 O(log N), 정렬 상태 자동 유지
- 최종 선택: C. Redis Sorted Set
- 결과: 200ms → 5ms (98% 개선)
- 배운 점: 단순 캐싱도 효과적이지만, 자료구조 선택이 성능과 구현 복잡도 모두에 영향을 미침. "어떻게 저장할까"보다 "어떻게 갱신하고 조회할까" 패턴을 먼저 분석해야 함

### 트러블슈팅 4 (Type: C)
- 제목: 동시성 제어 비교로 상황별 락 전략 선택 경험
- 기초 질문: "선착순 쿠폰 100개에 1000명이 동시에 요청한다면?"
- 파생 질문: 동시 요청에서 재고가 정확히 차감될까? / 어떤 락 전략이 가장 적합할까? / 성능과 정합성 사이 트레이드오프는?
- AS-IS: JMeter로 동시 요청 100개 시뮬레이션 → 재고 5개인데 10개 주문 성공 (overselling 발생)
- 독립적 해결책:
  - A. Optimistic Lock (@Version): 정합성 ✓, 평균 응답 450ms — 충돌 시 재시도 비용, 높은 경합에서 성능 저하
  - B. Pessimistic Lock (PESSIMISTIC_WRITE): 정합성 ✓, 평균 응답 300ms — 락 대기로 응답 시간 증가, 분산 환경 한계
  - C. Redis 분산 락 (Redisson): 정합성 ✓, 평균 응답 180ms — 분산 환경 지원, Redis 장애 시 SPOF
- 최종 선택: 상황별 전략 선택 기준 확보
  - 낮은 경합 → Optimistic Lock
  - 높은 경합 + 단일 DB → Pessimistic Lock
  - 분산 환경 → Redis 분산 락
- 결과: 시나리오별로 적절한 전략을 선택할 수 있는 기준 확보
- 배운 점: "최고의 락"은 없고, 트래픽 수준·인프라·비즈니스 요구사항에 따라 선택해야 함. 각 전략을 직접 측정해보니 이론과 실제 성능 차이를 체감할 수 있었음
